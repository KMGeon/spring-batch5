# 배치 도메인 이해

## Job

- 잡은 배치에서 가장 최상위에 있는 개념이다. ( 하나의 처리 작업 전체를 의미한다. )
- 잡은 크게 Simple, Flow로 나누어지게 된다. (Flow 추후에 설명)


### 전체적인 흐름
1. JobLauncher가 실행을 시작합니다. job과 parameters를 받아 run(job, parameters) 메소드를 호출
2. Job 객체가 생성됩니다. 이 Job은 여러 Step으로 구성
3. Job의 execute() 메소드가 호출되어 실제 작업이 시작
4. Job 내부의 Step 1 + .... 이 실행됩니다. 
5. 마지막으로 execute(JobExecution) 메소드가 호출되어 작업 결과를 처리 


### SimpleJob 생성
```java
@Configuration
@RequiredArgsConstructor
public class SimpleJob {
    private static final Logger logger = LoggerFactory.getLogger(SimpleJob.class);

    private final JobRepository jobRepository;
    private final PlatformTransactionManager transactionManager;


    @Bean
    public Job simpleJob_1() throws Exception {
        return new JobBuilder("batchJob", jobRepository)
                .incrementer(new RunIdIncrementer())
                .start(simpleStep_1())
                .build();
    }

    @Bean
    Step simpleStep_1() {
        return new StepBuilder("step1", jobRepository)
                .tasklet((contribution, chunkContext) -> {
                    logger.info("step1 was excuted!");
                    return RepeatStatus.FINISHED;
                }, transactionManager)
                .build();
    }
}
```

```
2024-10-15 22:21:09 [INFO ] [] [] Job: [SimpleJob: [name=batchJob]] launched with the following parameters: [{'run.id':'{value=4, type=class java.lang.Long, identifying=true}'}]
2024-10-15 22:21:09 [INFO ] [] [] Executing step: [step1]
2024-10-15 22:21:09 [INFO ] [] [] step1 was excuted!
2024-10-15 22:21:09 [INFO ] [] [] Step: [step1] executed in 36ms
2024-10-15 22:21:09 [INFO ] [] [] Job: [SimpleJob: [name=batchJob]] completed with the following parameters: [{'run.id':'{value=4, type=class java.lang.Long, identifying=true}'}] and the following status: [COMPLETED] in 94ms
```

- 해당 로그를 통해서 PARAM을 받은 뒤에 Job이 실행되고 Job에 step이 실행되어 로그가 찍히고 execute를 통해서 데이터가 들어간 것을 확인할 수 있다.



## JobInstance

- 잡 인스턴스는 간단하게 new()의 인스턴스와 같다고 생각하면 된다. 
- new를 통해 인스턴스를 2개를 만들면 같은 형태이지만 완벽하게 같지는 않다. Job Instance 또한 마찬가지이다.
- 만약에 정산을 처리하는 Job이 있다고 생각하자 하나의 Job에서 매일 동작하지만 Param으로 날짜를 받으면 결국 다른 의미를 가지게 된다.

> 처음 Job + JobParameter를 가지게 되면 새로운 JobInstance 생성 , 이전에 실행을 한 경우 존재하는 JobInstance를 반환한다.

```java
@Slf4j
@Configuration
@RequiredArgsConstructor
public class JobInstance {

    private final JobRepository jobRepository;
    private final PlatformTransactionManager transactionManager;

    @Bean
    public Job simpleJob2() throws Exception {
        return new JobBuilder("simpleJob2", jobRepository)
                .start(simpleStep2())
                .build();
    }

    @Bean
    Step simpleStep2() {
        return new StepBuilder("simpleStep2", jobRepository)
                .tasklet((contribution, chunkContext) -> {
                    log.info("step1 was excuted!");
                    return RepeatStatus.FINISHED;
                }, transactionManager)
                .build();
    }
}
```
- 해당 코드는 위에 동일한 코드이다. 하지만 처음이라고 생각하고 생각해보자
- 우리는 위에 execute()를 통해서 정보를 저장한다고 했다. 이것은 DB에 Batch의 실행 정보를 저장한다.

- 똑같은 Job을 2번 실행을 하면 2번 로그가 찍히지 않는다.
- `select * from BATCH_JOB_INSTANCE;`을 통해서 정보를 살펴보면 Job의 정보가 있는데 JobKey는 Param을 통해 암호화를 통해서 처리한 것이다.
- 즉. `Job name + parameter가 같다면 이전에 동일한 잡을 반환한다.` 
```json
[
        {
        "JOB_INSTANCE_ID": 1,
        "VERSION": 0,
        "JOB_NAME": "simpleJob2",
        "JOB_KEY": "d41d8cd98f00b204e9800998ecf8427e"
        }
]
```
